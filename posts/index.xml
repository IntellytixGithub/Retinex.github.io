<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Aditya Nandani</title>
    <link>https://aditya-nandani.github.io/posts/</link>
    <description>Recent content in Posts on Aditya Nandani</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://aditya-nandani.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Single Scale Retinex for Low-Light Image Enhancement in Autonomous Vehicles</title>
      <link>https://aditya-nandani.github.io/posts/single-scale-retinex/</link>
      <pubDate>Sun, 10 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://aditya-nandani.github.io/posts/single-scale-retinex/</guid>
      <description>A detailed explanation and implementation guide of Single Scale Retinex (SSR) for improving visibility in low-light driving conditions.</description>
      <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Driving in low-light conditions poses a serious challenge for autonomous vehicles.
Whether it’s nighttime driving, navigating through tunnels, or facing bad weather, the camera feed often suffers from poor visibility.
This reduced quality makes it harder for the perception system to detect lane markings, pedestrians, and obstacles — ultimately impacting safety.</p>
<p>To address this, image enhancement techniques are used to improve brightness and bring out hidden details without distorting the scene. One such powerful method is Single Scale Retinex (SSR) — a technique inspired by the way our eyes and brain perceive images under different lighting conditions.</p>
<p>In this blog, we’ll explore the fundamentals of SSR, understand its working principle, implement it in Python, and analyze its results.</p>
<h2 id="retinex-theory--a-quick-background">Retinex Theory – A Quick Background</h2>
<p>The Retinex theory, proposed by Edwin H. Land, is based on the combined action of the retina (light detection) and the cortex (visual processing) in the human visual system.
Its goal is color constancy — ensuring that objects appear with the same color, regardless of lighting.</p>
<p><strong>Key Idea:</strong><br>
An image can be thought of as the product of:</p>
<ul>
<li><strong>Reflectance (R)</strong> → the true color and texture of objects.</li>
<li><strong>Illumination (L)</strong> → the varying light falling on the scene.</li>
</ul>
<p>Mathematically:</p>
<pre tabindex="0"><code>I(x,y) = R(x,y) × L(x,y)
</code></pre><p>The Retinex approach extracts reflectance by removing the illumination component:</p>
<pre tabindex="0"><code>R(x,y) = log(I(x,y)) − log(L(x,y))
</code></pre><p>This logarithmic operation compresses dynamic range and reduces lighting effects.</p>
<h2 id="single-scale-retinex-ssr">Single Scale Retinex (SSR)</h2>
<p>Single Scale Retinex applies the Retinex formula at a single Gaussian scale.<br>
It works by:</p>
<ol>
<li>Converting the image to a floating-point format and avoiding log(0) by adding a small constant.</li>
<li>Applying a Gaussian blur to estimate the illumination.</li>
<li>Subtracting the blurred image (illumination) from the original image in the log domain.</li>
<li>Normalizing the output for display.</li>
</ol>
<p>The Gaussian scale parameter (<strong>σ</strong>) is crucial:</p>
<ul>
<li><strong>Small σ</strong> → enhances small details but may introduce noise.</li>
<li><strong>Large σ</strong> → smoothens illumination more but reduces fine detail enhancement.</li>
</ul>
<p><strong>Formula:</strong></p>
<pre tabindex="0"><code>Rssr(x,y) = log(I(x,y)) − log(Gσ ∗ I(x,y))
</code></pre><p>Where:</p>
<ul>
<li><strong>Gσ</strong> = Gaussian kernel with standard deviation σ.</li>
</ul>
<h2 id="implementation-in-python">Implementation in Python</h2>
<p>Here’s a simple implementation using OpenCV and NumPy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> cv2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function: Core SSR formula</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">singleScaleRetinex</span>(img, variance):
</span></span><span style="display:flex;"><span>    retinex <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>log10(img) <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>log10(cv2<span style="color:#f92672">.</span>GaussianBlur(img, (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), variance))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> retinex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function: Full SSR Pipeline</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">SSR</span>(img, variance):
</span></span><span style="display:flex;"><span>    img <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float64(img) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>    img_retinex <span style="color:#f92672">=</span> singleScaleRetinex(img, variance)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(img_retinex<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">2</span>]):
</span></span><span style="display:flex;"><span>        unique, count <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>unique(np<span style="color:#f92672">.</span>int32(img_retinex[:, :, i] <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>), return_counts<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> u, c <span style="color:#f92672">in</span> zip(unique, count):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> u <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                zero_count <span style="color:#f92672">=</span> c
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        low_val <span style="color:#f92672">=</span> unique[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">/</span> <span style="color:#ae81ff">100.0</span>
</span></span><span style="display:flex;"><span>        high_val <span style="color:#f92672">=</span> unique[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">/</span> <span style="color:#ae81ff">100.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> u, c <span style="color:#f92672">in</span> zip(unique, count):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> u <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> c <span style="color:#f92672">&lt;</span> zero_count <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1</span>:
</span></span><span style="display:flex;"><span>                low_val <span style="color:#f92672">=</span> u <span style="color:#f92672">/</span> <span style="color:#ae81ff">100.0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> u <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> c <span style="color:#f92672">&lt;</span> zero_count <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1</span>:
</span></span><span style="display:flex;"><span>                high_val <span style="color:#f92672">=</span> u <span style="color:#f92672">/</span> <span style="color:#ae81ff">100.0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        img_retinex[:, :, i] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>maximum(np<span style="color:#f92672">.</span>minimum(img_retinex[:, :, i], high_val), low_val)
</span></span><span style="display:flex;"><span>        img_retinex[:, :, i] <span style="color:#f92672">=</span> (img_retinex[:, :, i] <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>min(img_retinex[:, :, i])) <span style="color:#f92672">/</span>   (np<span style="color:#f92672">.</span>max(img_retinex[:, :, i]) <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>min(img_retinex[:, :, i])) <span style="color:#f92672">*</span> <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    img_retinex <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>uint8(img_retinex)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> img_retinex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>variance <span style="color:#f92672">=</span> <span style="color:#ae81ff">500</span>
</span></span><span style="display:flex;"><span>img <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>imread(<span style="color:#e6db74">&#39;./test/test2.jpg&#39;</span>)
</span></span><span style="display:flex;"><span>img_ssr <span style="color:#f92672">=</span> SSR(img, variance)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cv2<span style="color:#f92672">.</span>imshow(<span style="color:#e6db74">&#39;Original&#39;</span>, img)
</span></span><span style="display:flex;"><span>cv2<span style="color:#f92672">.</span>imshow(<span style="color:#e6db74">&#39;SSR&#39;</span>, img_ssr)
</span></span><span style="display:flex;"><span>cv2<span style="color:#f92672">.</span>imwrite(<span style="color:#e6db74">&#39;SSR.jpg&#39;</span>, img_ssr)
</span></span><span style="display:flex;"><span>cv2<span style="color:#f92672">.</span>waitKey(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>cv2<span style="color:#f92672">.</span>destroyAllWindows()
</span></span></code></pre></div><h2 id="results">Results</h2>
<p>Below are the results of applying SSR to a low-light road scene:</p>
<p><strong>Original Image:</strong><br>
<img alt="Original Image" loading="lazy" src="/images/input.jpg"></p>
<p><strong>SSR Enhanced Image:</strong><br>
<img alt="SSR Enhanced Image" loading="lazy" src="/images/result.png"></p>
<h2 id="observations">Observations</h2>
<ul>
<li>Shadows are brighter, revealing hidden details.</li>
<li>The overall contrast is improved.</li>
<li>Road markings and objects are more visible.</li>
</ul>
<h2 id="advantages--limitations">Advantages &amp; Limitations</h2>
<p><strong>Advantages:</strong></p>
<ul>
<li>Simple and computationally efficient.</li>
<li>Effective in enhancing visibility.</li>
<li>Works well for many natural images.</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li>May produce halo effects around bright objects.</li>
<li>Can amplify noise in very dark areas.</li>
<li>One scale may not handle varying illumination across the image — leading to the need for Multi-Scale Retinex (MSR).</li>
</ul>
<h2 id="references">References</h2>
<ol>
<li>Land, E. H., “The Retinex Theory of Color Vision,” <em>Scientific American</em>, 1977.</li>
<li>Jobson, D. J., Rahman, Z., and Woodell, G. A., “Properties and performance of a center/surround retinex,” <em>IEEE Trans. Image Processing</em>, 1997.</li>
<li>OpenCV documentation.</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Essential Linux Commands reference</title>
      <link>https://aditya-nandani.github.io/posts/my-first-post/</link>
      <pubDate>Tue, 29 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://aditya-nandani.github.io/posts/my-first-post/</guid>
      <description></description>
    </item>
  </channel>
</rss>
